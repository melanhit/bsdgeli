Index: sbin/geom/class/eli/geom_eli.c
===================================================================
--- sbin/geom/class/eli/geom_eli.c	(revision 329982)
+++ sbin/geom/class/eli/geom_eli.c	(working copy)
@@ -137,6 +137,7 @@
 		{ 'P', "nonewpassphrase", NULL, G_TYPE_BOOL },
 		{ 's', "sectorsize", "0", G_TYPE_NUMBER },
 		{ 'V', "mdversion", "-1", G_TYPE_NUMBER },
+		{ 'H', "header", "", G_TYPE_STRING },
 		G_OPT_SENTINEL
 	    },
 	    "- an alias for 'init'"
@@ -148,9 +149,10 @@
 		{ 'k', "keyfile", G_VAL_OPTIONAL, G_TYPE_STRING | G_TYPE_MULTI },
 		{ 'p', "nopassphrase", NULL, G_TYPE_BOOL },
 		{ 'r', "readonly", NULL, G_TYPE_BOOL },
+		{ 'H', "header", "", G_TYPE_STRING },
 		G_OPT_SENTINEL
 	    },
-	    "[-dprv] [-j passfile] [-k keyfile] prov"
+	    "[-dprv] [-j passfile] [-k keyfile] [-H header] prov"
 	},
 	{ "detach", 0, NULL,
 	    {
@@ -637,7 +639,7 @@
 		int fd;
 
 		/* This is a file probably. */
-		fd = open(prov, O_WRONLY | O_TRUNC);
+		fd = open(prov, O_WRONLY | O_TRUNC | O_CREAT, 0600);
 		if (fd == -1) {
 			gctl_error(req, "Cannot open %s: %s.", prov,
 			    strerror(errno));
@@ -670,10 +672,9 @@
 eli_init(struct gctl_req *req)
 {
 	struct g_eli_metadata md;
-	unsigned char sector[sizeof(struct g_eli_metadata)];
 	unsigned char key[G_ELI_USERKEYLEN];
 	char backfile[MAXPATHLEN];
-	const char *str, *prov;
+	const char *str, *prov, *hdname;
 	unsigned int secsize, version;
 	off_t mediasize;
 	intmax_t val;
@@ -839,17 +840,26 @@
 		return;
 	}
 
-	eli_metadata_encode(&md, sector);
+	hdname = gctl_get_ascii(req, "header");
+	if(*hdname == '\0')
+		str = prov;
+	else
+		str = hdname;
+
+	error = eli_metadata_store(req, str, &md);
 	bzero(&md, sizeof(md));
-	error = g_metadata_store(prov, sector, sizeof(sector));
-	bzero(sector, sizeof(sector));
 	if (error != 0) {
-		gctl_error(req, "Cannot store metadata on %s: %s.", prov,
+		gctl_error(req, "Cannot store metadata on %s: %s.", str,
 		    strerror(error));
 		return;
 	}
 	if (verbose)
-		printf("Metadata value stored on %s.\n", prov);
+		printf("Metadata value stored on %s.\n", str);
+
+	/* Don't backup metadata if use detached header */
+	if(*hdname != '\0' && strcmp(backfile, "none") != 0)
+		return;
+
 	/* Backup metadata to a file. */
 	str = gctl_get_ascii(req, "backupfile");
 	if (str[0] != '\0') {
@@ -883,7 +893,7 @@
 {
 	struct g_eli_metadata md;
 	unsigned char key[G_ELI_USERKEYLEN];
-	const char *prov;
+	const char *str, *prov, *hdname;
 	off_t mediasize;
 	int nargs;
 
@@ -893,8 +903,14 @@
 		return;
 	}
 	prov = gctl_get_ascii(req, "arg0");
+	hdname = gctl_get_ascii(req, "header");
 
-	if (eli_metadata_read(req, prov, &md) == -1)
+	if(*hdname == '\0')
+		str = prov;
+	else
+		str = hdname;
+
+	if (eli_metadata_read(req, str, &md) == -1)
 		return;
 
 	mediasize = g_get_mediasize(prov);
@@ -908,6 +924,9 @@
 		return;
 	}
 
+	if(*hdname != '\0')
+		gctl_ro_param(req, "hd", sizeof(md), &md);
+
 	gctl_ro_param(req, "key", sizeof(key), key);
 	if (gctl_issue(req) == NULL) {
 		if (verbose)
